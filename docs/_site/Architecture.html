<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>FlexLib Architecture | FlexLib API Documentation </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="FlexLib Architecture | FlexLib API Documentation ">
      
      
      <link rel="icon" href="favicon.ico">
      <link rel="stylesheet" href="public/docfx.min.css">
      <link rel="stylesheet" href="public/main.css">
      <meta name="docfx:navrel" content="toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="index.html">
            <img id="logo" class="svg" src="logo.svg" alt="FlexLib">
            FlexLib
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="flexlib-architecture">FlexLib Architecture</h1>

<p>This document provides a comprehensive overview of FlexLib's architecture, design patterns, and internal workings.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#system-overview">System Overview</a></li>
<li><a href="#core-components">Core Components</a></li>
<li><a href="#design-patterns">Design Patterns</a></li>
<li><a href="#threading-model">Threading Model</a></li>
<li><a href="#network-protocol">Network Protocol</a></li>
<li><a href="#data-flow">Data Flow</a></li>
<li><a href="#best-practices">Best Practices</a></li>
</ul>
<hr>
<h2 id="system-overview">System Overview</h2>
<p>FlexLib is a client library that communicates with FlexRadio software-defined radios over TCP/IP networks. It provides a high-level C# API for radio control, audio streaming, and telemetry monitoring.</p>
<h3 id="high-level-architecture">High-Level Architecture</h3>
<pre><code>┌─────────────────────────────────────────────────┐
│           Your Application                      │
│    (Console, WPF, WinForms, Service)            │
└────────────────┬────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────┐
│              FlexLib API                        │
│  ┌─────────┬──────────┬────────────┬─────────┐ │
│  │   API   │  Radio   │   Slice    │  Meter  │ │
│  │  Class  │  Class   │   Class    │  Class  │ │
│  └─────────┴──────────┴────────────┴─────────┘ │
│  ┌─────────────────────────────────────────┐   │
│  │    Discovery &amp; Communication Layer      │   │
│  └─────────────────────────────────────────┘   │
└────────────────┬────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────┐
│           Network Layer                         │
│  ┌──────────┬────────────┬──────────────────┐  │
│  │   UDP    │    TCP     │   VITA-49        │  │
│  │Discovery │  Commands  │   Streaming      │  │
│  └──────────┴────────────┴──────────────────┘  │
└────────────────┬────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────┐
│           FlexRadio Device                      │
│      (FLEX-6300, 6400, 6600, etc.)              │
└─────────────────────────────────────────────────┘
</code></pre>
<h3 id="key-layers">Key Layers</h3>
<ol>
<li><strong>Application Layer</strong>: Your code using FlexLib</li>
<li><strong>API Layer</strong>: High-level classes (Radio, Slice, Meter, etc.)</li>
<li><strong>Communication Layer</strong>: Network protocol handling</li>
<li><strong>Transport Layer</strong>: UDP/TCP/VITA-49 protocols</li>
<li><strong>Hardware Layer</strong>: FlexRadio SDR device</li>
</ol>
<hr>
<h2 id="core-components">Core Components</h2>
<h3 id="api-class">API Class</h3>
<p><strong>Purpose</strong>: Central initialization and radio management.</p>
<p><strong>Responsibilities</strong>:</p>
<ul>
<li>Initialize discovery system</li>
<li>Maintain list of discovered radios</li>
<li>Manage radio lifecycle</li>
<li>Provide static access to radios</li>
</ul>
<p><strong>Key Members</strong>:</p>
<pre><code class="lang-csharp">public static void Init()
public static List&lt;Radio&gt; RadioList
public static void CloseSession()
public static event RadioAddedEventHandler RadioAdded
public static event RadioRemovedEventHandler RadioRemoved
</code></pre>
<p><strong>Usage Pattern</strong>:</p>
<pre><code class="lang-csharp">API.Init();                    // Start discovery
var radios = API.RadioList;    // Get discovered radios
API.CloseSession();            // Cleanup
</code></pre>
<hr>
<h3 id="radio-class">Radio Class</h3>
<p><strong>Purpose</strong>: Represents a single FlexRadio device.</p>
<p><strong>Responsibilities</strong>:</p>
<ul>
<li>Manage connection to radio</li>
<li>Handle command/response protocol</li>
<li>Maintain radio state</li>
<li>Manage child objects (Slices, Panadapters, etc.)</li>
<li>Process status updates</li>
<li>Handle audio/data streams</li>
</ul>
<p><strong>Key Collections</strong>:</p>
<pre><code class="lang-csharp">public ObservableCollection&lt;Slice&gt; SliceList
public ObservableCollection&lt;Panadapter&gt; PanadapterList
public ObservableCollection&lt;Waterfall&gt; WaterfallList
public ObservableCollection&lt;Meter&gt; MeterList
public ObservableCollection&lt;Memory&gt; MemoryList
</code></pre>
<p><strong>State Properties</strong>:</p>
<pre><code class="lang-csharp">public bool Connected          // Connection status
public string Nickname         // User-defined name
public string Model            // Radio model
public string Serial           // Serial number
public IPAddress IP            // Network address
public string Version          // Firmware version
</code></pre>
<p><strong>Design</strong>: Implements <code>INotifyPropertyChanged</code> for real-time updates.</p>
<hr>
<h3 id="slice-class">Slice Class</h3>
<p><strong>Purpose</strong>: Represents a receiver/transmitter channel.</p>
<p><strong>Responsibilities</strong>:</p>
<ul>
<li>Frequency control</li>
<li>Mode selection</li>
<li>Filter configuration</li>
<li>Audio routing</li>
<li>PTT control</li>
<li>Antenna selection</li>
</ul>
<p><strong>Key Properties</strong>:</p>
<pre><code class="lang-csharp">public double Freq             // Frequency in MHz
public string Mode             // Operating mode
public int FilterLow           // Low-pass filter Hz
public int FilterHigh          // High-pass filter Hz
public bool Active             // Slice active state
public bool Transmit           // PTT state
public string RXAnt            // RX antenna
public string TXAnt            // TX antenna
</code></pre>
<p><strong>Lifecycle</strong>:</p>
<ol>
<li>Created by <code>Radio.RequestSliceFromRadio()</code></li>
<li>Configured via property setters</li>
<li>Monitored via <code>PropertyChanged</code> events</li>
<li>Removed by <code>Radio.RemoveSlice(slice)</code></li>
</ol>
<hr>
<h3 id="discovery-class">Discovery Class</h3>
<p><strong>Purpose</strong>: Discover FlexRadio devices on the network.</p>
<p><strong>Mechanism</strong>:</p>
<ul>
<li>Opens UDP socket on port 4992</li>
<li>Sends discovery packets periodically</li>
<li>Listens for radio announcements</li>
<li>Parses discovery information</li>
<li>Notifies API class of new radios</li>
</ul>
<p><strong>Protocol</strong>:</p>
<pre><code>Radio → UDP Broadcast → Port 4992
Format: Key=Value pairs
Example: &quot;model=FLEX-6600 serial=1234-5678-9012-3456 ...&quot;
</code></pre>
<p><strong>Discovery Packet Fields</strong>:</p>
<ul>
<li><code>discovery_protocol_version</code></li>
<li><code>model</code></li>
<li><code>serial</code></li>
<li><code>version</code></li>
<li><code>nickname</code></li>
<li><code>ip</code></li>
<li><code>port</code></li>
<li><code>status</code></li>
</ul>
<hr>
<h3 id="audio-streaming-classes">Audio Streaming Classes</h3>
<h4 id="daxrxaudiostream">DAXRXAudioStream</h4>
<p><strong>Purpose</strong>: Receive audio from radio for playback or processing.</p>
<p><strong>Characteristics</strong>:</p>
<ul>
<li>Mono audio stream</li>
<li>24kHz, 48kHz, or 96kHz sample rate</li>
<li>32-bit float samples</li>
<li>VITA-49 packet protocol</li>
</ul>
<p><strong>Usage</strong>:</p>
<pre><code class="lang-csharp">var stream = radio.CreateDAXRXAudioStream(1); // DAX channel 1
stream.DataReady += (samples) =&gt; ProcessAudio(samples);
stream.Start();
</code></pre>
<h4 id="daxtxaudiostream">DAXTXAudioStream</h4>
<p><strong>Purpose</strong>: Send audio to radio for transmission.</p>
<p><strong>Usage</strong>: Provide audio samples for transmission.</p>
<h4 id="daxiqstream">DAXIQStream</h4>
<p><strong>Purpose</strong>: IQ data streaming for digital modes.</p>
<p><strong>Characteristics</strong>:</p>
<ul>
<li>Interleaved I/Q samples</li>
<li>High sample rate (up to 192kHz)</li>
<li>Used for SDR applications</li>
</ul>
<hr>
<h3 id="meter-class">Meter Class</h3>
<p><strong>Purpose</strong>: Real-time telemetry monitoring.</p>
<p><strong>Types of Meters</strong>:</p>
<ul>
<li><strong>Signal meters</strong>: SIGNAL, MICPEAK, COMPPEAK</li>
<li><strong>Power meters</strong>: FWD, REF, SWR</li>
<li><strong>System meters</strong>: VOLTAGE, TEMP</li>
<li><strong>Audio meters</strong>: LEVELPEAK, LEVELAVG</li>
</ul>
<p><strong>Usage Pattern</strong>:</p>
<pre><code class="lang-csharp">radio.MeterAdded += (meter) =&gt;
{
    meter.DataReady += (data) =&gt;
    {
        Console.WriteLine($&quot;{meter.Name}: {data.Value}&quot;);
    };
};
</code></pre>
<hr>
<h2 id="design-patterns">Design Patterns</h2>
<h3 id="observer-pattern">Observer Pattern</h3>
<p><strong>Usage</strong>: Extensive use of C# events for state changes.</p>
<p><strong>Implementation</strong>:</p>
<pre><code class="lang-csharp">// INotifyPropertyChanged for object property changes
public event PropertyChangedEventHandler PropertyChanged;

// Custom events for object lifecycle
public event SliceAddedEventHandler SliceAdded;
public event SliceRemovedEventHandler SliceRemoved;

// Data events for streaming
public event DataReadyEventHandler DataReady;
</code></pre>
<p><strong>Benefits</strong>:</p>
<ul>
<li>Decoupled architecture</li>
<li>Real-time updates</li>
<li>Event-driven programming model</li>
<li>Natural fit for UI applications</li>
</ul>
<hr>
<h3 id="command-pattern">Command Pattern</h3>
<p><strong>Usage</strong>: Radio command/response protocol.</p>
<p><strong>Implementation</strong>:</p>
<pre><code class="lang-csharp">// Internal command structure
class RadioCommand
{
    public string Command { get; set; }
    public int SequenceNumber { get; set; }
    public TaskCompletionSource&lt;string&gt; Response { get; set; }
}

// Example usage internally:
SendCommand(&quot;slice tune &quot; + index + &quot; &quot; + freq);
</code></pre>
<p><strong>Protocol Format</strong>:</p>
<pre><code>Client → Radio: &quot;C&lt;seq&gt;|&lt;command&gt; &lt;args&gt;&quot;
Radio → Client: &quot;R&lt;seq&gt;|&lt;result&gt;&quot;
</code></pre>
<p><strong>Example</strong>:</p>
<pre><code>Client: &quot;C1|slice create&quot;
Radio: &quot;R1|0|slice 0&quot;
</code></pre>
<hr>
<h3 id="factory-pattern">Factory Pattern</h3>
<p><strong>Usage</strong>: Creating streaming objects and connections.</p>
<p><strong>Examples</strong>:</p>
<pre><code class="lang-csharp">// Factory methods on Radio class
public DAXRXAudioStream CreateDAXRXAudioStream(int daxChannel);
public DAXIQStream CreateDAXIQStream(int daxChannel);
public RXRemoteAudioStream CreateRXRemoteAudioStream();
</code></pre>
<p><strong>Benefits</strong>:</p>
<ul>
<li>Centralized object creation</li>
<li>Proper initialization</li>
<li>Resource management</li>
</ul>
<hr>
<h3 id="mvvm-pattern-support">MVVM Pattern Support</h3>
<p><strong>Integration</strong>: FlexLib supports MVVM via <code>ObservableObject</code> base class.</p>
<p><strong>Provided by</strong>: UiWpfFramework</p>
<p><strong>Usage</strong>:</p>
<pre><code class="lang-csharp">// Radio, Slice, and other classes inherit from ObservableObject
public class Slice : ObservableObject
{
    private double _freq;
    
    public double Freq
    {
        get { return _freq; }
        set
        {
            if (_freq != value)
            {
                _freq = value;
                RaisePropertyChanged(&quot;Freq&quot;);
            }
        }
    }
}
</code></pre>
<p><strong>Benefits for WPF/UI</strong>:</p>
<ul>
<li>Data binding support</li>
<li>Automatic UI updates</li>
<li>Reduced boilerplate code</li>
</ul>
<hr>
<h2 id="threading-model">Threading Model</h2>
<h3 id="main-threads">Main Threads</h3>
<ol>
<li><strong>UI Thread</strong>: Your application's main thread</li>
<li><strong>Discovery Thread</strong>: UDP discovery listener</li>
<li><strong>Command Thread</strong>: TCP command socket reader</li>
<li><strong>VITA Thread(s)</strong>: Audio/IQ packet processors</li>
<li><strong>Meter Thread</strong>: Meter data processing</li>
</ol>
<h3 id="thread-safety">Thread Safety</h3>
<p><strong>Event Callbacks</strong>: FlexLib events fire on <strong>background threads</strong>, not the UI thread.</p>
<p><strong>Important</strong>: For WPF/UI updates, use <code>Dispatcher.Invoke()</code>:</p>
<pre><code class="lang-csharp">radio.PropertyChanged += (sender, e) =&gt;
{
    // This runs on a background thread!
    
    Application.Current.Dispatcher.Invoke(() =&gt;
    {
        // Now safe to update UI
        statusLabel.Content = radio.Status;
    });
};
</code></pre>
<h3 id="synchronization">Synchronization</h3>
<p>FlexLib uses:</p>
<ul>
<li><code>lock</code> statements for critical sections</li>
<li><code>ConcurrentDictionary</code> for thread-safe collections</li>
<li><code>ImmutableList</code> for read-only collections</li>
<li><code>ObservableCollection</code> with proper locking</li>
</ul>
<hr>
<h2 id="network-protocol">Network Protocol</h2>
<h3 id="discovery-protocol-udp">Discovery Protocol (UDP)</h3>
<p><strong>Port</strong>: 4992<br>
<strong>Type</strong>: UDP Broadcast<br>
<strong>Direction</strong>: Radio → Client</p>
<p><strong>Packet Format</strong>:</p>
<pre><code>discovery_protocol_version=3.0.0.2
model=FLEX-6600
serial=1234-5678-9012-3456
version=3.2.39
nickname=K5DTO Station
ip=192.168.1.100
port=4992
status=Available
...
</code></pre>
<p><strong>Timing</strong>: Radios broadcast every 5-10 seconds.</p>
<hr>
<h3 id="command-protocol-tcp">Command Protocol (TCP)</h3>
<p><strong>Port</strong>: 4992<br>
<strong>Type</strong>: TCP<br>
<strong>Format</strong>: ASCII text, newline-terminated</p>
<p><strong>Command Format</strong>:</p>
<pre><code>C&lt;sequence&gt;|&lt;command&gt; &lt;args&gt;
</code></pre>
<p><strong>Response Format</strong>:</p>
<pre><code>R&lt;sequence&gt;|&lt;result_code&gt;|&lt;data&gt;
</code></pre>
<p><strong>Status Updates</strong> (unsolicited):</p>
<pre><code>S&lt;hex_handle&gt;|&lt;object_type&gt; &lt;properties&gt;
</code></pre>
<p><strong>Examples</strong>:</p>
<pre><code># Create a slice
Client: C1|slice create
Radio:  R1|0|slice 0

# Tune slice
Client: C2|slice tune 0 14.200
Radio:  R2|0

# Status update
Radio:  S12345678|slice 0 freq=14.200000 mode=USB
</code></pre>
<p><strong>Result Codes</strong>:</p>
<ul>
<li><code>0</code>: Success</li>
<li>Non-zero: Error (with error message)</li>
</ul>
<hr>
<h3 id="vita-49-protocol-udp">VITA-49 Protocol (UDP)</h3>
<p><strong>Purpose</strong>: High-performance audio/IQ streaming.</p>
<p><strong>Characteristics</strong>:</p>
<ul>
<li>UDP packets</li>
<li>Binary format</li>
<li>Header + payload structure</li>
<li>Sequence numbers for packet loss detection</li>
<li>Timestamps for synchronization</li>
</ul>
<p><strong>Packet Structure</strong>:</p>
<pre><code>┌────────────────┐
│  VITA Header   │ 28 bytes
├────────────────┤
│  Audio/IQ Data │ Variable
└────────────────┘
</code></pre>
<p><strong>Stream Types</strong>:</p>
<ul>
<li><strong>Audio</strong>: 32-bit float PCM</li>
<li><strong>IQ</strong>: Interleaved I/Q samples</li>
<li><strong>DAX</strong>: Multiple channels possible</li>
</ul>
<hr>
<h2 id="data-flow">Data Flow</h2>
<h3 id="connection-flow">Connection Flow</h3>
<pre><code>1. Application calls API.Init()
   ↓
2. Discovery starts, sends UDP broadcasts
   ↓
3. Radio responds with discovery packet
   ↓
4. Radio object created, added to RadioList
   ↓
5. RadioAdded event fired
   ↓
6. Application calls radio.Connect()
   ↓
7. TCP connection established
   ↓
8. Initial status updates received
   ↓
9. Connected property set to true
   ↓
10. Application can now control radio
</code></pre>
<h3 id="slice-creation-flow">Slice Creation Flow</h3>
<pre><code>1. Application calls radio.RequestSliceFromRadio()
   ↓
2. Command sent: &quot;C&lt;seq&gt;|slice create&quot;
   ↓
3. Radio responds: &quot;R&lt;seq&gt;|0|slice 0&quot;
   ↓
4. Radio sends status: &quot;S...|slice 0 freq=14.200 ...&quot;
   ↓
5. Slice object created
   ↓
6. SliceAdded event fired
   ↓
7. Slice appears in radio.SliceList
</code></pre>
<h3 id="property-change-flow">Property Change Flow</h3>
<pre><code>1. Application sets: slice.Freq = 14.200
   ↓
2. Property setter checks if value changed
   ↓
3. Command sent: &quot;C&lt;seq&gt;|slice tune 0 14.200&quot;
   ↓
4. Radio responds: &quot;R&lt;seq&gt;|0&quot;
   ↓
5. Radio applies change
   ↓
6. Radio sends status: &quot;S...|slice 0 freq=14.200000&quot;
   ↓
7. Status parser updates local property
   ↓
8. PropertyChanged event fired
   ↓
9. UI/application updates
</code></pre>
<hr>
<h2 id="best-practices">Best Practices</h2>
<h3 id="initialization">Initialization</h3>
<p>✅ <strong>Do</strong>:</p>
<pre><code class="lang-csharp">// Initialize once at startup
API.ProgramName = &quot;MyApp&quot;;
API.Init();

// Subscribe to events before Init()
API.RadioAdded += OnRadioAdded;
API.Init();
</code></pre>
<p>❌ <strong>Don't</strong>:</p>
<pre><code class="lang-csharp">// Don't call Init() multiple times
API.Init();
API.Init(); // BAD!

// Don't forget to set ProgramName
API.Init(); // Missing ProgramName
</code></pre>
<hr>
<h3 id="connection-management">Connection Management</h3>
<p>✅ <strong>Do</strong>:</p>
<pre><code class="lang-csharp">// Check availability before connecting
if (radio.Available &amp;&amp; !radio.Connected)
{
    radio.Connect();
}

// Wait for connection with timeout
for (int i = 0; i &lt; 50 &amp;&amp; !radio.Connected; i++)
    await Task.Delay(100);
</code></pre>
<p>❌ <strong>Don't</strong>:</p>
<pre><code class="lang-csharp">// Don't assume immediate connection
radio.Connect();
var slice = radio.SliceList.First(); // May fail!

// Don't connect without checking
radio.Connect(); // Maybe already connected or unavailable
</code></pre>
<hr>
<h3 id="property-updates">Property Updates</h3>
<p>✅ <strong>Do</strong>:</p>
<pre><code class="lang-csharp">// Use PropertyChanged for updates
slice.PropertyChanged += (s, e) =&gt;
{
    if (e.PropertyName == &quot;Freq&quot;)
        Console.WriteLine($&quot;Frequency: {slice.Freq}&quot;);
};

// Batch related changes
slice.Freq = 14.200;
slice.Mode = &quot;USB&quot;;
slice.FilterLow = 200;
slice.FilterHigh = 2800;
</code></pre>
<p>❌ <strong>Don't</strong>:</p>
<pre><code class="lang-csharp">// Don't poll properties
while (true)
{
    Console.WriteLine(slice.Freq); // Inefficient!
    Thread.Sleep(100);
}
</code></pre>
<hr>
<h3 id="threading">Threading</h3>
<p>✅ <strong>Do</strong>:</p>
<pre><code class="lang-csharp">// Use Dispatcher for UI updates
radio.PropertyChanged += (s, e) =&gt;
{
    Dispatcher.Invoke(() =&gt;
    {
        statusLabel.Content = radio.Status;
    });
};

// Use async/await properly
await Task.Run(() =&gt; LongRunningOperation());
</code></pre>
<p>❌ <strong>Don't</strong>:</p>
<pre><code class="lang-csharp">// Don't update UI from events directly
radio.PropertyChanged += (s, e) =&gt;
{
    statusLabel.Content = radio.Status; // Cross-thread!
};
</code></pre>
<hr>
<h3 id="resource-cleanup">Resource Cleanup</h3>
<p>✅ <strong>Do</strong>:</p>
<pre><code class="lang-csharp">try
{
    API.Init();
    // Your code...
}
finally
{
    // Always cleanup
    foreach (var radio in API.RadioList)
        radio.Disconnect();
    
    API.CloseSession();
}
</code></pre>
<p>❌ <strong>Don't</strong>:</p>
<pre><code class="lang-csharp">// Don't forget cleanup
API.Init();
// ... code ...
return; // Leaked resources!
</code></pre>
<hr>
<h3 id="error-handling">Error Handling</h3>
<p>✅ <strong>Do</strong>:</p>
<pre><code class="lang-csharp">try
{
    radio.Connect();
}
catch (Exception ex)
{
    Console.WriteLine($&quot;Connection failed: {ex.Message}&quot;);
    // Handle gracefully
}

// Check results
if (radio.Connected)
{
    // Proceed
}
else
{
    // Handle failure
}
</code></pre>
<p>❌ <strong>Don't</strong>:</p>
<pre><code class="lang-csharp">// Don't ignore errors
radio.Connect(); // May throw or fail silently

// Don't swallow exceptions
try { radio.Connect(); }
catch { } // Lost error information!
</code></pre>
<hr>
<h2 id="performance-considerations">Performance Considerations</h2>
<h3 id="discovery-performance">Discovery Performance</h3>
<ul>
<li>Discovery takes 2-5 seconds typically</li>
<li>Wait adequate time before assuming no radios</li>
<li>Don't call <code>API.Init()</code> repeatedly</li>
</ul>
<h3 id="command-latency">Command Latency</h3>
<ul>
<li>TCP commands: ~10-50ms round trip</li>
<li>Status updates: Asynchronous, varies</li>
<li>Don't send commands too rapidly</li>
</ul>
<h3 id="audio-streaming">Audio Streaming</h3>
<ul>
<li>VITA-49 uses UDP: Some packet loss expected</li>
<li>Buffer audio to handle jitter</li>
<li>Use appropriate sample rates for your needs</li>
</ul>
<h3 id="memory-usage">Memory Usage</h3>
<ul>
<li>Each radio: ~10-50 MB depending on configuration</li>
<li>Audio streams: Additional buffers</li>
<li>Monitor memory if managing many radios</li>
</ul>
<hr>
<h2 id="debugging-tips">Debugging Tips</h2>
<h3 id="enable-logging">Enable Logging</h3>
<p>FlexLib can enable debug logging:</p>
<pre><code>Create file:
%APPDATA%\FlexRadio Systems\log_discovery.txt
%APPDATA%\FlexRadio Systems\log_disconnect.txt
</code></pre>
<h3 id="network-monitoring">Network Monitoring</h3>
<p>Use Wireshark to monitor:</p>
<ul>
<li>UDP port 4992 (discovery)</li>
<li>TCP port 4992 (commands)</li>
<li>UDP streaming ports (audio/IQ)</li>
</ul>
<h3 id="common-issues">Common Issues</h3>
<ol>
<li><strong>No radios discovered</strong>: Check network, firewall</li>
<li><strong>Connection fails</strong>: Radio may be in use</li>
<li><strong>Commands ignored</strong>: Check radio connection</li>
<li><strong>No audio</strong>: Verify DAX configuration</li>
<li><strong>UI freezes</strong>: Use Dispatcher for events</li>
</ol>
<hr>
<h2 id="summary">Summary</h2>
<p>FlexLib provides a powerful, event-driven API for FlexRadio control:</p>
<ul>
<li><strong>Clean architecture</strong>: Layered design with clear separation</li>
<li><strong>Flexible</strong>: Supports console, GUI, and service applications</li>
<li><strong>Real-time</strong>: Event-driven for responsive applications</li>
<li><strong>Comprehensive</strong>: Full radio control and streaming</li>
<li><strong>Well-tested</strong>: Used in SmartSDR and many applications</li>
</ul>
<p>Understanding this architecture will help you build robust, efficient FlexRadio applications!</p>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Copyright © 2018-2024 FlexRadio Systems. All rights reserved.
        </div>
      </div>
    </footer>
  </body>
</html>
